post_notifi_events 

handles an HTTP request, processes its JSON body, sends a message to a Service Bus queue after encryption, extracts MsgEventIdvalues if the request body meets certain conditions, and returns a success message. 


	1.	Trigger: The function is triggered by an HTTP request.
	2.	Request Body: The JSON data from the HTTP request body is obtained using req.get_json().
	3.	Service Bus: The function uses a Service Bus client to send a single message to a queue named PENDING_DNA_TXN_EVENTS_QUEUE. The message is the JSON string obtained from the request body, which is then encrypted before being sent to the Service Bus.
	4.	Message Event IDs: If the length of the request body is greater than 0 , the function extracts a list of MsgEventId values from the "Events" key in the request body and assigns it to message_event_ids.
	5.	Return: If the function successfully processes the request, it returns a success message.

post_pd_bai_process_log 

	1.	Trigger: The function is triggered by an HTTP request.
	2.	Request Body: The JSON data from the HTTP request body is obtained using req.get_json().
	3.	action=req_body.get(PDBaiProcessDefaults.action.value).
	4.	Process Action: The function calls process_action(logger, req_body, action) with the extracted action.
	5.	Action Handling:
			If the action is CREATE (value 'C'), the function awaits PdBaiProcessLogUtility(logger).process_create_request(req_body).
			If the action is UPDATE, the function awaits PdBaiProcessLogUtility(logger).process_update_request(req_body).
	6.	Process Create Request:
			If the status is RUNNING, the function validates the request for creating an entry into pd_bai_process_log.
			If the status is SKIPPED, the function validates the request for a skipped entry into pd_bai_process_log.
	7.	Validation and Creation:
			The function validates the request and updates the eventStartTime and eventEndTime in the request body.
			The request body is mapped to the pd_bai_process_log fields.
			The mapped data is loaded into a pd_bai_process_log_object.
			The pd_bai_process_log_object is inserted into the pd_bai_process_log.
	8.	Process Update Request:
			If the action is UPDATE, the function processes the request to update the status of a pd_bai_process_log_record based on the provided ID.

process_ach_transactions 

This function appears to handle incoming messages related to ACH transactions from a Service Bus topic. It decrypts the message, processes the transaction details, and then inserts or updates records in the current day transaction table (cd_trans_info) and transaction exception table based on the extracted information. 

	1.	Trigger: The function is triggered by messages from a Service Bus topic.
	2.	Message Decryption: The encrypted message body is obtained from the triggered message using message.get_body().decode(), and then decrypted using a decryption function.
	3.	JSON Parsing: The decrypted message body is parsed as JSON using json.loads() to obtain transaction_details.
	4.	Transaction Initialization: A Transaction object is initialized with transaction_details.
	5.	Transaction Details Extraction: The AchTransactionInfo class is used to extract transaction details into a dictionary format using get_dict().
	6.	CD Transaction Info Model: An instance of a class is initialized and returns a dictionary representing cd_transaction_info_model_obj.
	7.	CD Transaction Info Upsert: The upsert_into_cd_trans_info method of CdTransactionInfoDao is called to perform an upsert operation (update if exists, insert if not) into the current day transaction table.
	8.	Transaction Exception Handling:
			A TransactionException object is initialized with specific parameters.
			The TransactionExceptionSchema().load() method is used to load the data into a transaction_exception_model_obj.
			The TransactionExceptionDao().insert_transaction_exception() method is called to insert data into the transaction exception table.








process_pending_dna_transactions_events 

The process_pending_dna_transactions_eventsfunction is an Azure Function that gets activated when messages arrive from a Service Bus. Once it receives a message, the function decrypts its content and gets a list of events from it. After that, it sends these events to a specific topic in batches. If there are any events that couldn't be sent, the function logs a warning message with the count of failed events. Lastly, it gives back a success response to show how many events were successfully handled and added to the topic. 

	1.	Trigger: The function is triggered by messages from a Service Bus.
	2.	Message Handling:
			The function receives a ServiceBusMessage object named msg.
			The delivery count of the message is obtained using msg.delivery_count.
	3.	Message Decryption: The message body is decrypted using a decryption function. The decrypted JSON data is obtained using json.loads(decrypt(encrypted_message_body)).
	4.	Event Processing:
			The events are extracted from the decrypted JSON data as decrypted_json["Events"].
			The size of the events list is calculated using len(events).
	5.	Sending Events to Topic:
			The events are sent to a topic using ServiceBus.send_batch_message_to_topic(events, logger, DNA TOPIC_NAME, sql_filter=ALL_DELIVERY_CONSTANT).
			The number of messages sent is stored in messages_sent.
	6.	Handling Failed Messages:
			If there are failed messages (determined by messages_failed > 0), a warning is logged with the count of failed events using logger.log_warning(f"Failed events count: {messages_failed}").
			The function then returns a success response indicating the number of successfully inserted events into the topic using return await logger.send_success_response(f"Successfully inserted {messages_sent} events into the topic").


